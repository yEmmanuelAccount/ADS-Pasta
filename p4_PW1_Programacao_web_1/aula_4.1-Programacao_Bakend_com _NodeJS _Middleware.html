<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../styles/00-home.css">
    <title>Aula 4.1: Programação Bakend com NodeJS (Middleware)</title>
</head>
<body class="pw1-page">
    <header>
        <a href="./" class="btn-voltar">Voltar</a>
        <div class="nav-direita">
            <a href="aula_3-Introdução_APIs_e_RESTful.html" class="btn-nav" title="Anterior">&lt;</a>
            <a href="aula_4.2-Programacao_Bakend_com_NodeJS _Integracao_com_Banco_de_Dados.html" class="btn-nav" title="Próximo">&gt;</a>
        </div>
    </header>
    
    <div class="conteudo">
        <h1>Programação Backend com NodeJS <br> (Middleware)</h1>

        <h2>Conceito e Funcionamento de Middleware</h2>
        <p><em>Middlewares</em> são funções fundamentais que interceptam o ciclo entre o pedido HTTP do cliente e a resposta final do servidor. No Express, eles atuam como manipuladores de requisição organizados em uma <strong>pilha sequencial</strong>.</p>

        <h3>Responsabilidades Típicas</h3>
        <p>Em vez de uma função única e complexa, o middleware permite dividir a lógica em pequenas etapas modulares:</p>
        
        <div>Manipulação de Requisição</div>
        <ul>
            <li>Execução de <strong>logging</strong> para monitoramento.</li>
            <li>Autenticação de usuários e verificação de permissões.</li>
            <li>Injeção de cabeçalhos ou dados nos objetos <code>request</code> e <code>response</code>.</li>
            <li>Encerramento prematuro do ciclo (ex: em caso de erro de validação).</li>
        </ul>

        <h2>Express e Middleware</h2>
        <p>O framework Express é construído essencialmente sobre o conceito de middleware. Até mesmo os roteadores (GET, POST) são tratados como middlewares ativados por caminhos específicos.</p>

        <div>Assinatura da Função</div>
        <p>Uma função de middleware padrão segue a assinatura: <code>function(request, response, next)</code>. O método <code>next()</code> é o motor que autoriza a requisição a avançar para o próximo item na pilha.</p>

        <h2>Tratamento de Erros e Autenticação</h2>
        <p>Middlewares especializados garantem a segurança e a resiliência da aplicação.</p>

        <h3>Middleware de Erros</h3>
        <p>Diferente do padrão, o middleware de erro possui <strong>quatro parâmetros</strong>: <code>(error, request, response, next)</code>. Ele é acionado automaticamente quando qualquer middleware anterior envia um erro através de <code>next(erro)</code>.</p>

        <div>Padronização de Respostas</div>
        <p>Uma boa prática é criar classes de erro customizadas (ex: <code>AppErrors</code>) para manter a consistência dos códigos de status e mensagens enviadas ao front-end.</p>

        <h3>Middleware de Autenticação</h3>
        <p>É o guardião das rotas privadas da API. Ele segue um fluxo lógico de validação:</p>
        
        <div>Fluxo de Validação de Token</div>
        <ol>
            <li>Extração do token do cabeçalho <code>Authorization</code> (formato <em>Bearer</em>).</li>
            <li>Validação criptográfica usando bibliotecas como <code>jsonwebtoken</code>.</li>
            <li>Injeção do ID do usuário validado no objeto <code>request</code>.</li>
            <li>Chamada do <code>next()</code> para permitir acesso ao recurso solicitado.</li>
        </ol>

        <div>TypeScript e Middlewares</div>
        <p>Ao utilizar TypeScript, é necessário configurar o <code>tsconfig.json</code> e realizar o <em>Type Definition</em> para garantir que o compilador reconheça propriedades customizadas adicionadas ao objeto de requisição.</p>
    </div>
</body>
</html>